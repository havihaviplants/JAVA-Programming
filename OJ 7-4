[7장 문제-4]

수정:11.08. 10:21
     PersonManger 메뉴 항목 오류 문제 해결하였음.
     자동오류체크 및 OJ에서  PersonManger 메뉴 항목이 잘못되어 있었음.
     수정 이전에 clc에서 test 파일 다운 받은 학생들은 새로 다운 받으시기 바랍니다.
     이 문제를 제보해 준 김소율 학생에게 감사드립니다.   

//----------------------------------------------------------------------------
// 아래 문제를 해결하는 도중 출력이 잘못되었거나 문제 설명과 출력이 일치하지 않거나 오타가 있거나 등등
// 조금이라도 문제에 이상한 것이 있으면 주저하지 말고 jhshim@chosun.ac.kr로 알려 주시기 바랍니다.
//----------------------------------------------------------------------------

/******************************************************************************
 * 프로젝트 및 소스파일 생성
 ******************************************************************************/
// 1) 이클립스에서 CH7-4 프로젝트를 만들어라. 
// 2) 기존 CH7-3 프로젝트에서 소스파일들을 모두 복사하라.
//    즉, 기존 소스 파일들을 모두 선택한 후 CH7-4/src/(default package) 위로 드래깅한 후 
//    Ctrl를 누른채 드랍한다.
// 3) clc의 [강의자료실]에서 CH7-4 과제와 관련된 자동오류체크를 위한 파일들을 다운받는다
//    만약 test 폴더 밑에 또 test 폴더가 있다면(즉, test/test) 안쪽 test 폴더를 사용하라. 


/******************************************************************************
 * [코드 추가 1]
 ******************************************************************************/
// 프로그램의 맨 앞쪽 주석 부분의 "Author: " 행 다음의 내용을 아래 내용으로 교체하라.
//----------------------------------------------------------------------------

//  + Memo: getWordCountMap(), wordCount(), countWordList() 멤버 함수 구현

/******************************************************************************
 * 코드 추가 2
 ******************************************************************************/
// 자주 메모 메뉴까지 진입해야 하는 번거로움을 피하기 위해 
// 1) 기존의 MainMenu::run() 함수 전체를 주석 처리하라.
// 2) 아래 함수를 그 뒤에 배치하라. 임시로 이 함수를 사용할 예정이다.
//-----------------------------------------------------------------------------
    public static void run() {
        new Memo("").run();
    }
//-----------------------------------------------------------------------------


/******************************************************************************
 * 문제: 1
 * 요점: String, Map을 활용하는 문제
 ******************************************************************************/
// Memo::wordCount() 함수를 구현하라.
// 이 함수는 mStr에 들어 있는 각 단어별 출현 횟수를 출력한다. 
// 아래 실행 결과를 먼저 참고하고, [문제 1-1]과 [문제 1-2]을 해결하라.

===============================================================================
==  문제 1 실행 결과
===============================================================================

+++++++++++++++++++++ Memo Management Menu +++++++++++++++++++
+ 0.exit 1.display 2.find 3.findReplace 4.compare 5.dispByLn +
+ 6.delLn 7.replLn 8.scrollUp 9.scrollDown 10.inputMemo      +
+ 11.wordCount 12.countWordList                              +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
menu item? 11
----------------
Word      Count
----------------
-          21
EIGHT       8
Indian      2
and         2
eight       8
five        5
four        4
greater     2
in          4
is          2
much        2
of          5
seven       7
six         6
so          3
ten        10
the         9
three       3
to          3
----------------

/******************************************************************************
 * 문제 1-1
 ******************************************************************************/
// 먼저 아래 getWordCountMap() 함수를 Memo::wordCount() 함수 앞에 배치하고,
// ToDo 부분의 주석을 참고하여 코드를 완성하라.
//-----------------------------------------------------------------------------
// 이 함수는 Memo::mStr에 들어 있는 문자열을 빼내 이를 단어 단위로 토큰을 자른 후 
// 각 단어별 출현 횟수를 Map에 저장한 후 해당 Map을 반환한다. 
// 리턴 데이터 타입인 Map< String, Integer >에서 String은 단어이며, 
// Integer는 해당 단어의 출현 횟수이다. 반환하는 Map으로는 TreeMap 또는 HashMap 중에서
// 단어별 정렬이 미리 되어 있는 적절한 Map을 생성해서 리턴해야 한다.
//-----------------------------------------------------------------------------
    private Map< String, Integer > getWordCountMap() { // ch7_3
        /* ToDo:
        mStr에서 전체를 하나의 문자열로 빼낸다. (compare() 함수 참고)
        이 문자열을 공백문자("\\s")를 구분자로 해서 토큰을 자른 후 문자열 배열인 words 저장한다.
        문제의 목적(단어별 정렬이 미리 되어 있는)에 맞는 <단어, 출현횟수>를 저장할 수 있는 
            적절한 Map을 생성해서 wordCountMap에 저장한다.
        for-each 문을 이용하여 words의 각 단어 w에 대해
    		빈 문자열("")이 있을 수 있으므로 w가 빈 문자열인 경우 스킵한다.
    		wordCountMap에서 단어 w를 검색한다. 검색된 값은 출현 횟수인 Integer 객체이다.
    		검색 성공 실패는 교제 예제 7-5를 참고하라.
    		검색 실패면(처음 삽입 시) 횟수 1을 그냥 맵에 삽입한다. (그냥 숫자 1을 삽입하면 된다.)
    		검색에 성공했으면 기존 횟수를 1 증가시켜 다시 맵에 삽입한다. 
    		(Integer 객체에 대해 ++ 또는 += 연산자 적용 가능함)
    	}
    	return wordCountMap; // Map으로 자동 업 케스팅되어 리턴됨
    }
//-----------------------------------------------------------------------------

/******************************************************************************
 * 문제 1-2
 ******************************************************************************/
// 기존 wordCount()를 아래 내용으로 교체하고 ToDo 부분을 참고하여 코드를 완성하라.
//-----------------------------------------------------------------------------
// 이 함수 구현 시 아래 getWordCountMap()를 호출하여 
// mStr에 들어 있는 각 단어별 출현 횟수를 저장하고 있는 Map을 구한다. 
// Map에 있는 모든 단어들을 사전적 순서로 출력하되 실행결과처럼 단어와 그 단어의 출현횟수를 출력한다. 
// 단, 출현 횟수가 1인 단어는 출력하지 마라.
//-----------------------------------------------------------------------------
    void wordCount() { // Menu item 11
        var wordCountMap = getWordCountMap();
        System.out.println("----------------");
        System.out.println("Word      Count");
        System.out.println("----------------");
        /* 
        ToDo: PMbyMap::display(map)을 참고하여 아래를 구현하라.
        1) 위 wordCountMap의 엔트리 집합을 구해서 wcEntries에 저장하라.
               엔트리 집합 wcEntries은 Set< Map.Entry< String, Integer > > 타입이어야 한다.
               각 엔트리는 <단어, 단어의 출현횟수>이다. 
        2) for-each 문을 이용하여 엔트리 집합 wcEntries의 각 엔트리 wc에 대해
               wc에서 키(단어, word)와 값(단어 출현 횟수, count)을 구한 후 
               (PMbyMap::display(map)을 참고할 것) 이를 아래처럼 출력한다.
               if (count > 1)  // %-7s: 문자열을 7 칸 안에 출력하되 좌 맞춤
                   System.out.printf("%-7s    %2d\n", word, count);
        */
        System.out.println("----------------");
    }
//-----------------------------------------------------------------------------


/******************************************************************************
 * 문제: 2
 * 요점: String, Vector, Map을 활용하는 종합 문제
 ******************************************************************************/
// Memo::countWordList() 함수를 구현하라. 
//-----------------------------------------------------------------------------
// 이 함수는 mStr에 들어 있는 단어의 출현 횟수가 많은 단어를 순서적으로 출력한다.
// 출현 횟수가 동일한 단어들은 모두 한 행에 출력한다.
// 단, 출현 횟수가 1인 단어들은 출력하지 마라.
// 아래 실행 결과를 먼저 참고하고, [문제 2 구현 방법]을 참고하여 구현하라.

===============================================================================
==  문제 2 실행 결과
===============================================================================

+++++++++++++++++++++ Memo Management Menu +++++++++++++++++++
+ 0.exit 1.display 2.find 3.findReplace 4.compare 5.dispByLn +
+ 6.delLn 7.replLn 8.scrollUp 9.scrollDown 10.inputMemo      +
+ 11.wordCount 12.countWordList                              +
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
menu item? 12
----------------
Count  Words
----------------
21     - 
10     ten 
 9     the 
 8     EIGHT eight 
 7     seven 
 6     six 
 5     five of 
 4     four in 
 3     so three to 
 2     Indian and greater is much 
----------------

/******************************************************************************
 * 문제 2 구현 방법
 ******************************************************************************/
// 기존 countWordList()를 아래 내용으로 교체하고 ToDo 부분을 참고하여 코드를 완성하라.
//-----------------------------------------------------------------------------
    void countWordList() {
        var wordCountMap = getWordCountMap();

        /* ToDo: 먼저 구현한 wordCount()을 참고하여 아래를 구현하라.
        1) 위 wordCountMap의 엔트리 집합을 구해서 wcEntries에 저장하라.
        2) 키는 (단어의 출현 회수)이고, 값은 (동일한 출현 횟수를 가진 단어들을 저장할 수 있는 Vector)인
           Map을 생성하여 countWordsMap에 저장한다.
           즉, 이 맵의 엔트리는 < Integer, Vector< String > > 이다.
           이때 생성할 맵은 출현 횟수별로 정렬이 되어 있는 맵을 선택해야 한다.(작은 수에 큰 수로 정렬) 
        3) for-each 문을 이용하여 엔트리 집합 wcEntries의 각 엔트리 wc에 대해
               wc에서 키인 word와 값인 count를 구한다.
               count를 키로 사용해서 countWordsMap의 값인 wordVct 벡터를 검색한다.
               만약 검색에 실패 했다면 (처음 삽입 시)
                   문자열 백터를 새로 생성하여 wordVct에 저장한다.
                   wordVct를 countWordsMap에 삽입한다.
               wordVct에 word를 삽입한다.
        */
        System.out.println("----------------");
        System.out.println("Count  Words");
        System.out.println("----------------");

        // 아래는 키의 순서를 역순으로 재배치한 새로운 맵 reverseCWMap을 생성한다.
        // 이 맵은 단어의 출현 횟수가 큰 수부터 작은 수 순서로 횟수를 저장하고 있다.
        var reverseCWMap = countWordsMap.descendingMap();
        
        /* ToDo:
        1) 위 reverseCWMap의 엔트리 집합을 구해서 cwEntries에 저장하라.
        2) for-each 문을 이용하여 엔트리 집합 cwEntries의 각 엔트리 cw에 대해
               cw에서 키인 count를 구한다.
               count가 1이면 스킵한다.
               System.out.printf("%2d     ", count);
               cw에서 값인 wordVct 벡터를 구한다.
               for-each 문을 이용하여 벡터 wordVct의 각 원소 w에 대해
                   System.out.print(w+ " ");
               System.out.println();
        */
        System.out.println("----------------");
    }
//-----------------------------------------------------------------------------


/******************************************************************************
 * 코드 복원
 ******************************************************************************/
// 1) 임시로 사용했던 임시로 MainMenu::run()을 삭제하라.
// 2) 주석 처리된 기존 MainMenu::run() 함수 전체의 주석을 해제하라.
//-----------------------------------------------------------------------------

/******************************************************************************
 * 프로그램의 자동오류체크 방법
 ******************************************************************************/
// clc.chosun.ac.kr의 [강의자료실]의 "자동_오류_체크_방법" 파일을 참고하기 바란다.

// Main.java의 main() 함수 내에서 아래 문장의 [주석]을 제거하고 실행하면 자동오류체크가 실행된다.
        //int chk = 1; if (chk != 0) new AutoCheck(chk, true).run(); else

/******************************************************************************
 * 자동오류체크 실행결과
 ******************************************************************************/
ch7-4-1 : O
ch7-4-2 : O
ch7-4-3 : O
ch7-4-4 : O
Good bye!!

/******************************************************************************
 * 프로그램 제출
 ******************************************************************************/
// 1. 중요: Main.java의 main() 함수 내에서 아래 문장처럼 [주석] 처리한 후 저장하라.
        //int chk = 1; if (chk != 0) new AutoCheck(chk, true).run(); else
//    경고: 위 문장을 주석처리 하지 않은 채 제출할 경우 oj 시스템에서 컴파일 에러가 발생할 것이다. 
// 2. 프로그램 소스인 Main.java만을 oj.chosun.ac.kr에 제출하라. 
//    제출 시 AutoCheck.java 파일은 제출하지 않아도 된다.
//-----------------------------------------------------------------------------
