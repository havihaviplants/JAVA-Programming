/*
[4장 문제-2]

수정: 2023.9.21 12:20
     1) UI 클래스 내의 getLine() 함수 이름을 getNextLine() 으로 수정하라.
     2) UI.getLine(...)을 호출하는 모든 곳을 찾아 함수 이름을 UI.getNextLine(...)으로 수정하라.
     이 문제를 발견하여 통보해 준 양준석 학생에게 감사드립니다.

// 아래 문제를 해결하는 도중 출력이 잘못되었거나 문제 설명과 출력이 일치하지 않거나 오타가 있거나 등등
// 조금이라도 문제에 이상한 것이 있으면 주저하지 말고 jhshim@chosun.ac.kr로 알려 주시기 바랍니다.

/******************************************************************************
 * 프로젝트 및 소스파일 생성
 ******************************************************************************/
// 이클립스에서 기존의 CH4-1 프로젝트를 실행하라. 
// (즉, 기존과 동일한 workspace(작업공간) 내에서 실행하라.)
// [Project Explorer]에 CH4-1 프로젝트가 있는 상태에서 아래를 수행하라.
// 1) 메뉴 [File]->[New]->[Java Project] 한 후 새로운 프로젝트 CH4-2을 만들어라.
// 2) 메뉴 [File]->[New]->[Class] 를 선택한 후 아래처럼 입력하여 Main.java 소스 파일을 작성하라.
//    Source folder: CH4-2/src
//    Package: [이 부분은 비어 있어야 함: 반드시 확인할 것]
//    Name: Main
//    Modifiers: public

/******************************************************************************
 * 프로그램 테스트를 위한 입출력 파일 다운로드
 ******************************************************************************/
// 1. clc.chosun.ac.kr의 [강의자료실]에서 CH4-2 과제와 관련된 테스트용 파일을 다운받는다.
// 2. 압축파일을 풀면 test라는 폴더가 생성되고 그 밑에 .in 또는 .out 파일이 존재할 것이다.
// 3. 해당 test 폴더를 드래깅하여 이클립스의 [Project Explorer]의 CH4-2 프로젝트 위에 드랍한다.
// 4. 그러면 CH4-2 프로젝트 밑에 기존의 src 폴더 외에 test 폴더가 새로 생성되어 복사될 것이다.
// 5. 이 test 폴더를 펼치면 다양한 입력용 파일 .in과 출력용 .out 파일이 존재함을 확인할 수 있음

/******************************************************************************
 * 자동 오류 체크를 위한 AutoCheck.java 추가
 ******************************************************************************/
// 1. clc.chosun.ac.kr의 [강의자료실]에서 자동오류체크 소스 파일 AutoCheck.java를 다운받거나
//    또는 기존 CH3 프로젝트에 있던 AutoCheck.java를 선택한다.
// 2. AutoCheck.java 파일을 드래깅하여 이클립스의 [Project Explorer]의 CH4-2 프로젝트 밑의 
//    src 폴더 밑의 (defalut package) 위에 드랍한다. (이때 복사 옵션을 선택해서 삽입하라). 
// 3. 그러면 (defalut package)에 AutoCheck.java가 복사될 것이다. 
//-----------------------------------------------------------------------------


/******************************************************************************
 * [코드 추가 1]
 ******************************************************************************/
// 1) 기존의 프로젝트 CH4-1::Main.java의 내용을 모두 복사해서 프로젝트 CH4-2::Main.java에 삽입하라.
// 2) 프로그램의 맨 앞쪽 주석 부분의 "Author: " 행 다음의 내용을 아래 내용으로 교체하라.
//----------------------------------------------------------------------------

//  + Person(Scanner s) 생성자 추가
//  + CurrentUser::changePasswd() 추가, 메뉴 수정
//  + VectorPerson, Factory, PersonManager 클래스 추가
//  + MultiManager 수정

            
/******************************************************************************
 * [코드 추가 2] 아래 VectorPerson, Factory, PersonManager 클래스를 
 *             기존의 CurrentUser 클래스 아래, 즉 MultiManager 클래스 앞에 배치하라. 
 ******************************************************************************/

class VectorPerson
{
    static final int DEFAULT_SIZE = 10;

    private Person[] persons; // Person 객체 참조들의 배열, 즉 배열에 저장된 값이 Person 객체의 주소이다.
    private int count;        // persons 배열에 현재 삽입된 객체의 개수

    public VectorPerson() { this(DEFAULT_SIZE); }

    public VectorPerson(int capacity) {
        count = 0; // persons 배열에 현재 삽입된 객체의 개수는 0
        System.out.println("VectorPerson::VectorPerson("+capacity+")");
        persons = new Person[capacity]; // 객체 참조 배열 할당
    }
    // persons[index]의 값을 반환
    public Person get(int index) { return null; }
     
    // 할당 받은 persons 배열의 전체 길이를 반환함 (count가 아님)
    public int capacity() { return 0; }
     
    // persons 배열에 현재 삽입된 객체의 개수를 0으로 설정
    public void clear() { ; }
     
    // 현재 삽입된 객체 참조가 하나도 없으면 true, 있으면 false를 반환한다.
    // if 문장을 사용하지 말고 한 문장(return 비교연산자)으로 완셩할 것
    public boolean isEmpty() { return false; }
     
    // 현재 삽입된 객체의 개수를 반환
    public int size() { return 0; }

    // index 위치의 객체 p를 삭제한다. 즉, index+1부터 끝까지 객체들을 한칸씩 왼쪽으로 밀어 주어야 한다.
    // 자바에는 객체를 삭제하는 delete 명령어가 없다. 따라서 객체를 별도로 삭제할 필요는 없고 무시하라.
    void remove(int index) {
    }
    // persons 배열에 마지막 삽입된 원소 뒤에 새로운 원소 p를 삽입하고 현재 삽입된 객체 개수 증가
    // persons[]의 배열 크기가 작으면 extend_capacity()를 호출하여 먼저 배열을 확장한다.
    public void add(Person p) {
         if (count >= persons.length)
             extend_capacity();
         persons[count++] = p;
    }
    // 먼저 index부터 끝까지 객체들을 한칸씩 뒤로 밀어 준 후 index 위치에 객체 p를 삽입한다. 
    // persons[]의 배열 크기가 작으면 extend_capacity()를 호출하여 먼저 배열을 확장한다.
    public void add(int index, Person p) {
    }
    // persons[]의 배열 크기를 두배로 확장한다.
    // 기존 persons 변수를 다른 배열 변수에 임시로 저장한 후 
    // 현재의 두배 크기의 배열을 새로 할당 받아 persons에 저장한다.
    // 임시 변수에 있던 기존 값들을 모두 persons[]에 복사한다.
    public void extend_capacity() {
        // 별도의 지시가 있을 때가지 구현하지 않아도 됨
    }
}   // VectorPerson class: ch4_2

class Factory
{
    public void printInputNotice(String preMsg, String postMsg) {
        System.out.println("input"+preMsg+" [person information]"+postMsg+":");
    }
    public Person inputPerson(Scanner sc) { 
        return null; 
    }
}   // Factory class: ch4_2

class PersonManager
{
    static int cpCount = 0;
    private VectorPerson pVector;
    private Factory factory;
    private Person array[];

    public PersonManager(Person array[], Factory factory) {
        System.out.println("PersonManager(array[])");
        pVector = new VectorPerson();
        this.factory = factory;
        this.array = array;
        addArray();
        display();
    }

    public void run() {
        String menuStr =
            "=========== Person Management Menu ==========\n" +
            "= 0.exit 1.display 2.clear 3.reset 4.remove =\n" +
            "= 5.copy 6.append 7.insert 8.login          =\n" +
            "=============================================\n";
        final int MENU_COUNT = 9; // 상수 정의
        while (true) {
            int menuItem = UI.selectMenu(menuStr, MENU_COUNT);
            switch(menuItem) {
            case 1: display();         break;
            case 2: clear();           break;
            case 3: reset();           break;
            case 4: remove();          break;
            case 5: copy();            break;
            case 6: append();          break;
            case 7: insert();          break;
            case 8: login();           break;
            case 0:                    return;
            }
        }
    }
    public void display() { // Menu item 1
    }
    public void clear() {  // Menu item 2
    }
    public void reset() { // Menu item 3
    }
    public void remove() { // Menu item 4
    }
    public void copy() { // Menu item 5
    }
    // 아래 함수는 사용자로부터 새로 추가할 Person 객체의 수를 입력 받고 for문을 이용하여
    // 그 개수만큼의 Person 객체를 생성하고 인적정보를 입력받은 후 (factory.inputPerson()을 통해)
    // VectorPerson pVector의 맨 끝에 추가한다.
    /* append() 실행 시 아래 항목들을 복사해서 순서적으로 입력하면 편하게 인적정보를 입력할 수 있음
    3
    HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
    LeeMongRyong 1 65 true :Jong-ro 1-gil, Jongno-gu, Seoul:
    LeeSoonShin 2 80 true :1001, Jungang-daero, Yeonje-gu, Busan:
    */
    public void append() { // Menu item 6
    }
    public void insert() { // Menu item 7
    }
    // 사용자로부터 VectorPerson pVector에 저장된 사람들 중에서 로그인할 사람의 이름(name)과 비번을 입력받고
    // 해당 비번이 맞으면 CurrentUser의 객체를 생성하고 이 객체의 run() 멤버 함수를 호출한다.
    // 초기 비번은 설정되어 있지 않기에 그냥 엔터치면 된다.
    public void login() {  // Menu item 8
    }
    private void addArray() {
        for (Person p : array)
            pVector.add(p.clone()); // 배열의 각 원소를 복사한 후 pVector에  삽입함
    }
}   // ch4_2: PersonManager class

      
/******************************************************************************
 * [코드 추가 3] 기존의 MultiManager 클래스를 아래 MultiManager 클래스로 교체하라. 
 ******************************************************************************/

class MultiManager
{
    private Person persons[] = {
        new Person("p0", 10, 70.0, false, "Gwangju Nam-gu Bongseon-dong 21"),
        new Person("p1", 11, 61.1, true,  "Jong-ro 1-gil, Jongno-gu, Seoul"),
        new Person("p2", 12, 52.2, false, "1001, Jungang-daero, Yeonje-gu, Busan"),
        new Person("p3", 13, 83.3, true,  "100 Dunsan-ro Seo-gu Daejeon"),
        new Person("p4", 14, 64.4, false, "88 Gongpyeong-ro, Jung-gu, Daegu"),
    };
    // new를 이용해 동적으로 할당할 경우 소멸자 함수를 만들어 거기서 delete 해 주어야 함

    private Person allPersons[] = {
        persons[0], persons[1], persons[2], persons[3], persons[4],
    };

    public void run() {
        System.out.println("PersonManager::run() starts");
        var pm = new PersonManager(allPersons, new Factory());
        pm.run();
        System.out.println("PersonManager::run() returned");
    }
} // class MultiManager: ch4_1


===============================================================================
== 프로그램 실행 결과: 프로그램을 실행하면 아래와 같이 출력되어야 한다.
=============================================================================== 

******* Main Menu ********
* 0.exit 1.PersonManager *
* 2.ch2 3.ch3            *
**************************
menu item? 1
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
PersonManager::run() starts
PersonManager(array[])
VectorPerson::VectorPerson(10)
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person::clone()
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person::clone()
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person::clone()
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove =
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 0
PersonManager::run() returned

******* Main Menu ********
* 0.exit 1.PersonManager *
* 2.ch2 3.ch3            *
**************************
menu item? 

===============================================================================
== 위 프로그램 실행 결과 설명
=============================================================================== 
// 1) 아래 출력은 MultiManager::Person persons[] 배열 원소의 각 객체가 생성되면서 
//    Person() 생성자에 의해 출력된다.
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:

// 2) 아래는 주석의 함수에서 출력되었음
PersonManager::run() starts      // MultiManager::run()
PersonManager(array[])           // PersonManager(array[], factory) 생성자
VectorPerson::VectorPerson(10)   // PersonManager 생성자에서 new VectorPerson() 생성자

// 3) 아래 출력은 PersonManager(array[], factory) 생성자에서 PersonManager::addArray() 호출하고
//    addArray()는 arr[] 배열의 각 원소를 복사해서(p.clone()) pVector에 순서적으로 삽입(add())한다.
//    이때 각 원소를 복사하는 p.clone()에서 객체를 복사하여 새로운 객체를 생성할 때 생성자에서 출력된 것임
//    (arr[] 배열은 MultiManager::allPersons[]과 동일하며 이는 MultiManager::persons[]와 동일함)
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person::clone()
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person::clone()
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person::clone()
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:


===============================================================================
== 각 클래스 설명
=============================================================================== 
VectorPerson 클래스: 여러 개의 Person 객체들을 배열에 저장하고 있으며, 필요한 경우
    배열의 맨 끝에 또는 배열의 중간에 객체들을 삽입, 배열 중간의 객체 삭제, 배열 인덱스로 객체 얻어 오기,
    삽입 시 배열이 가득 찼으면 자동으로 배열 크기 늘려주기 등의 기능을 수행한다.  

PersonManager 클래스: 사용자에게 메뉴를 보여 주고 사용자가 선택한 메뉴 항목에 따라 
    VertorPerson에 Person 객체를 삽입하거나 VertorPerson에 있는 기존의 객체들을 
    삭제, 검색, 모든 객체 보여주기 등의 기능을 수행한다.

Factory 클래스는 키보드 또는 파일 등으로 부터 Person 객체의 각 멤버 정보를 읽어 들인 후 
    새로운 Person 객체를 생성하여 리턴해 준다. (추후 계속 기능이 추가될 예정임)

MultiManager 클래스는 여러 Person 객체를 미리 생성하여 persons[] 배열에 저장하고 있다가
    PersonManager 생성 시 초기값으로 이 배열을 넘겨 주는 역할을 한다. 
    PersonManager 생성자에서 이 배열에 저장된 각 객체를 복사하여 VectorPerson에 삽입한다.
    지금은 MultiManager::persons[] 배열에 Person 객체만 가지고 있지만 나중에 
    Person을 상속한 Student, Worker 클래스 객체들이 배열에 추가될 예정이다.


/******************************************************************************
 * 문제: 1
 * 요점: VectorPerson 멤버 함수 구현: size(), get(i), isEmpty(), capacity()
 ******************************************************************************/
// 1) PersonManager 클래스의 display() 함수에 아래 내용을 추가하라.
// 2) 아래 프로그램 실행 결과를 참고하여 VectorPerson 클래스에 있는
//    size(), get(i), isEmpty(), capacity() 멤버 함수들을 구현하라.
//    함수 구현시 VectorPerson 각 함수에 있는 주석을 참고하여 구현하라.
//-----------------------------------------------------------------------------

        int count = pVector.size();
        System.out.println("display(): count " + count);
        for (int i = 0; i < count; ++i) {
            System.out.print("[" + i + "] ");
            pVector.get(i).println();
        }
        System.out.println("empty():" + pVector.isEmpty() + ", size():" + pVector.size()
             + ", capacity():" + pVector.capacity());

===============================================================================
==  프로그램 실행 결과 1
=============================================================================== 

******* Main Menu ...
menu item? 1
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
PersonManager::run() starts
PersonManager(array[])
VectorPerson::VectorPerson(10)
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person::clone()
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person::clone()
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person::clone()
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
display(): count 5
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():5, capacity():10

=========== Person Management Menu ==========
= 0.exit 1.display ...
menu item? 1
display(): count 5
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():5, capacity():10

=========== Person Management Menu ...
menu item? 


/******************************************************************************
 * 문제: 2
 * 요점: VectorPerson 멤버 함수 구현: clear()
 ******************************************************************************/
// 1) PersonManager 클래스의 clear() 함수에 아래 내용을 추가하라.
// 2) 아래 프로그램 실행 결과를 참고하여 VectorPerson 클래스의 clear() 멤버 함수들을 구현하라.
//-----------------------------------------------------------------------------

        pVector.clear();
        display();

===============================================================================
==  프로그램 실행 결과 2
=============================================================================== 

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
=============================================
menu item? 2
display(): count 0
empty():true, size():0, capacity():10


/******************************************************************************
 * 문제: 3
 * 요점: VectorPerson 멤버 함수 구현: reset()
 ******************************************************************************/
// PersonManager 클래스의 reset() 함수에 아래 내용을 추가하라.
// pVector의 기존 데이타를 모두 무효화하고 PersonManager의 arr[]에 있는 객체를 모두 복사해서
// 새로운 객체를 생성한 후 pVector에 새로 삽입한다. 
// arr[]는 MultiManager의 persons[]와 메모리를 공유한다.
//-----------------------------------------------------------------------------

        pVector.clear();
        addArray();
        display();

===============================================================================
==  프로그램 실행 결과 3
=============================================================================== 

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
=============================================
menu item? 3
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person::clone()
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person::clone()
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person::clone()
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
display(): count 5
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():5, capacity():10


/******************************************************************************
 * 문제: 4
 * 요점: VectorPerson 멤버 함수 구현: remove()
 ******************************************************************************/
// 1) PersonManager 클래스의 remove() 함수에 아래 내용을 추가하라.
// 2) 아래 프로그램 실행 결과를 참고하여 VectorPerson 클래스의 remove() 멤버 함수들을 구현하라.
//-----------------------------------------------------------------------------

        if (pVector.size() == 0) {
            System.out.println("no entry to remove");
            return;
        }
        int index = UI.getIndex("index to delete? ", pVector.size());
        pVector.remove(index);
        display();

===============================================================================
==  프로그램 실행 결과 4
=============================================================================== 

=========== Person Management Menu ==========
= 0.exit 1.display ...
=============================================
menu item? 1
display(): count 5
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():5, capacity():10

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
menu item? 4
index to delete? 5
5: OUT of selection range(0 ~ 4) Try again!!
index to delete? -1
Input a positive INTEGER. Try again!!
index to delete? 0
display(): count 4
[0] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[1] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[2] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[3] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():4, capacity():10

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
menu item? 4
index to delete? 3
display(): count 3
[0] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[1] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[2] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
empty():false, size():3, capacity():10

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
menu item? 4
index to delete? 1
display(): count 2
[0] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[1] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
empty():false, size():2, capacity():10

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
menu item? 2
display(): count 0
empty():true, size():0, capacity():10

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
menu item? 4
no entry to remove


/******************************************************************************
 * 문제: 5
 * 요점: VectorPerson의 기존 멤버 함수 활용
 ******************************************************************************/
// PersonManager 클래스의 copy() 함수에 아래 내용을 추가하라.
// 이 함수는 기존에 pVector에 삽입되었던 모든 원소를 복사하고 
// 새로 복사된 객체의 각 멤버 변수를 적절히 변형한 후 
// 이를 다시 pVector의 맨 뒤에 삽입한다.
//-----------------------------------------------------------------------------

        cpCount++;
        for (int i = 0, size = pVector.size(); i < size; ++i) {
            Person p = pVector.get(i).clone();
            String name = p.getName();
            for (int j = 0; j < cpCount; ++j)
                name = name.charAt(0)+name;
            p.set(name);
            p.set(p.getId() + 20 * cpCount);
            p.set(p.getWeight() + cpCount);
            if (cpCount % 2 == 1)
                p.set(!p.getMarried());
            pVector.add(p);
        }
        display();

===============================================================================
==  프로그램 실행 결과 5
==  두 번째 복사할 때 에러가 발생하는데 이는 pVector의 배열이 모두 가득 찼기 때문에 발행하는 에러이다.
=============================================================================== 

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
=============================================
menu item? 1
display(): count 5
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():5, capacity():10

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login ...
menu item? 5
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person::clone()
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person::clone()
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person::clone()
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
display(): count 10
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[5] pp0 30 71.0 true :Gwangju Nam-gu Bongseon-dong 21:
[6] pp1 31 62.1 false :Jong-ro 1-gil, Jongno-gu, Seoul:
[7] pp2 32 53.2 true :1001, Jungang-daero, Yeonje-gu, Busan:
[8] pp3 33 84.3 false :100 Dunsan-ro Seo-gu Daejeon:
[9] pp4 34 65.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():10, capacity():10

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login ...
menu item? 5
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10
	at VectorPerson.add(TestMain.java:324)
	at PersonManager.copy(TestMain.java:427)
	at PersonManager.run(TestMain.java:379)
	at MultiManager.run(TestMain.java:476)
	at MainMenu.run(TestMain.java:53)
	at TestMain.run(TestMain.java:31)
	at TestMain.main(TestMain.java:25)


/******************************************************************************
 * 문제: 5-1
 * 요점: VectorPerson 멤버 함수 구현: extend_capacity()
 ******************************************************************************/
// 앞의 에러가 발생하지 않도록 VectorPerson 클래스의 extend_capacity() 함수을 구현하라.
// 이 함수는 VectorPerson 내의 persons[] 배열의 크기를 두 배로 늘려 준다.
// 구현시 extend_capacity() 앞에 있는 주석을 참고하라.
//-----------------------------------------------------------------------------

===============================================================================
==  프로그램 실행 결과 5-1
=============================================================================== 

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove ...
menu item? 1
display(): count 5
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():5, capacity():10

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 5
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
...
Person::clone()
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
display(): count 10
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
...
[9] pp4 34 65.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():10, capacity():10

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 5
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
VectorPerson: capacity extended to 20     // 출력되었는지 확인할 것
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
...
Person::clone()
Person(): pp4 34 65.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
display(): count 20
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
...
[19] pppp4 74 67.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():20, capacity():20

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove =
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 5
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
VectorPerson: capacity extended to 40     // 출력되었는지 확인할 것
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
...
Person::clone()
Person(): pppp4 74 67.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
display(): count 40
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[5] pp0 30 71.0 true :Gwangju Nam-gu Bongseon-dong 21:
[6] pp1 31 62.1 false :Jong-ro 1-gil, Jongno-gu, Seoul:
[7] pp2 32 53.2 true :1001, Jungang-daero, Yeonje-gu, Busan:
[8] pp3 33 84.3 false :100 Dunsan-ro Seo-gu Daejeon:
[9] pp4 34 65.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
[10] ppp0 50 72.0 false :Gwangju Nam-gu Bongseon-dong 21:
[11] ppp1 51 63.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[12] ppp2 52 54.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[13] ppp3 53 85.3 true :100 Dunsan-ro Seo-gu Daejeon:
[14] ppp4 54 66.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[15] pppp0 70 73.0 true :Gwangju Nam-gu Bongseon-dong 21:
[16] pppp1 71 64.1 false :Jong-ro 1-gil, Jongno-gu, Seoul:
[17] pppp2 72 55.2 true :1001, Jungang-daero, Yeonje-gu, Busan:
[18] pppp3 73 86.3 false :100 Dunsan-ro Seo-gu Daejeon:
[19] pppp4 74 67.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
[20] pppp0 70 73.0 true :Gwangju Nam-gu Bongseon-dong 21:
[21] pppp1 71 64.1 false :Jong-ro 1-gil, Jongno-gu, Seoul:
[22] pppp2 72 55.2 true :1001, Jungang-daero, Yeonje-gu, Busan:
[23] pppp3 73 86.3 false :100 Dunsan-ro Seo-gu Daejeon:
[24] pppp4 74 67.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
[25] ppppp0 90 74.0 false :Gwangju Nam-gu Bongseon-dong 21:
[26] ppppp1 91 65.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[27] ppppp2 92 56.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[28] ppppp3 93 87.3 true :100 Dunsan-ro Seo-gu Daejeon:
[29] ppppp4 94 68.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[30] pppppp0 110 75.0 true :Gwangju Nam-gu Bongseon-dong 21:
[31] pppppp1 111 66.1 false :Jong-ro 1-gil, Jongno-gu, Seoul:
[32] pppppp2 112 57.2 true :1001, Jungang-daero, Yeonje-gu, Busan:
[33] pppppp3 113 88.3 false :100 Dunsan-ro Seo-gu Daejeon:
[34] pppppp4 114 69.4 true :88 Gongpyeong-ro, Jung-gu, Daegu:
[35] ppppppp0 130 76.0 false :Gwangju Nam-gu Bongseon-dong 21:
[36] ppppppp1 131 67.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[37] ppppppp2 132 58.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[38] ppppppp3 133 89.3 true :100 Dunsan-ro Seo-gu Daejeon:
[39] ppppppp4 134 70.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():40, capacity():40


/******************************************************************************
 * 문제: 6
 * 요점: Factory::inputPerson(sc), Person::Person(sc), Person::inputMembers(sc)
 ******************************************************************************/
// 1) PersonManager 클래스의 append() 함수에 아래 내용을 추가하라.
//    사용자로부터 여러 사람의 정보를 입력 받아 Person 객체를 생성한 후 pVector의 맨 뒤에 삽입함
//-----------------------------------------------------------------------------

        int count = UI.getPosInt("number of persons to append? ");
        factory.printInputNotice(" "+Integer.toString(count), " to append");
        for (int i = 0; i < count; ++i) {
            Person p = factory.inputPerson(UI.scan); // 한 사람의 정보를 입력 받음
            if (p != null) pVector.add(p);
        }
        display();

//-----------------------------------------------------------------------------
// 2) Factory 클래스의 inputPerson(Scanner sc) 함수에 아래 내용을 추가하라.
//    Person 객체 p를(각각의 멤버 값은 스캐너 sc로부터 입력 받음) 생성해서 리턴함
//-----------------------------------------------------------------------------

        // user 100 65 true :426 hakdong-ro, Gangnam-gu, Seoul:
        var p = new Person(sc); // 위 행처럼 입력된 사람 정보를 입력 받음
        if (UI.echo_input) p.println(); // 자동오류체크시 출력됨
        return p; 

//-----------------------------------------------------------------------------
// 3) Person 클래스에 아래 생성자를 추가하라.
//    inputMembers(sc) 멤버 함수를 호출해서 객체의 각 멤버 값을 스캐너 sc로부터 입력 받음
//-----------------------------------------------------------------------------

    public Person(Scanner sc) { inputMembers(sc); }

//-----------------------------------------------------------------------------
// 4) Person 클래스에 private void inputMembers(Scanner sc) 멤버 함수를 구현하라.
//    함수 위치를 클래스의 맨 마지막에 배치하라.
//    이 함수는 객체의 각 멤버 값을 스캐너 sc로부터 입력 받는다.
//    이 함수 구현 시 Person::input(Scanner s) 함수의 내용을 참고하여 동일하게 구현하라.
//-----------------------------------------------------------------------------
// 5) inputMembers(Scanner sc)가 구현되었으면 input() 함수를 아래와 같이 수정하라. 
//-----------------------------------------------------------------------------

    void input(Scanner sc) { 
        inputMembers(sc); 
    }

//-----------------------------------------------------------------------------

===============================================================================
==  프로그램 실행 결과 6
=============================================================================== 

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove =
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 6
number of persons to append? -1
Input a positive INTEGER. Try again!!
number of persons to append? 3
input 3 [person information] to append:
HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
LeeMongRyong 1 65 true :Jong-ro 1-gil, Jongno-gu, Seoul:
LeeSoonShin 2 80 true :1001, Jungang-daero, Yeonje-gu, Busan:
display(): count 8
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[5] HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
[6] LeeMongRyong 1 65.0 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[7] LeeSoonShin 2 80.0 true :1001, Jungang-daero, Yeonje-gu, Busan:
empty():false, size():8, capacity():10


/******************************************************************************
 * 문제: 7
 * 요점: VectorPerson::add(int index, Person p)
 ******************************************************************************/
// 1) PersonManager 클래스의 insert() 함수에 아래 내용을 추가하라.
//    사용자로부터 새로운 객체를 삽입할 인덱스와 사람의 정보를 입력 받아 Person 객체를 생성한 후 
//    pVector의 중간(지정한 인덱스)에 삽입함
// 2) 실행결과를 참고하여 VectorPerson::add(int index, Person p) 멤버 함수를 구현하라.
//    구현시 VectorPerson의 이 함수 앞쪽의 주석을 참고하라.
//-----------------------------------------------------------------------------

        int index = 0;
        if (pVector.size() > 0) {
            index = UI.getIndex("index to insert in front? ", pVector.size()+1);
            if (index < 0) return;
        }
        factory.printInputNotice("", " to insert");
        Person p = factory.inputPerson(UI.scan);
        if (p == null) return;
        pVector.add(index, p);
        display();

===============================================================================
==  프로그램 실행 결과 7
=============================================================================== 

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 7
index to insert in front? abc
Input an INTEGER. Try again!!
index to insert in front? -1
Input a positive INTEGER. Try again!!
index to insert in front? 6
6: OUT of selection range(0 ~ 5) Try again!!
index to insert in front? 5
input [person information] to insert:
HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
display(): count 6
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[5] HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
empty():false, size():6, capacity():10

=========== Person Management Menu ...
= 5.copy 6.append 7.insert ...
menu item? 7
index to insert in front? 0
input [person information] to insert:
LeeMongRyong 1 65 true :Jong-ro 1-gil, Jongno-gu, Seoul:
display(): count 7
[0] LeeMongRyong 1 65.0 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[1] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[2] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[3] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[4] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[5] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[6] HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
empty():false, size():7, capacity():10

=========== Person Management Menu ...
= 5.copy 6.append 7.insert ...
menu item? 7
index to insert in front? 3
input [person information] to insert:
LeeSoonShin 2 80 true :1001, Jungang-daero, Yeonje-gu, Busan:
display(): count 8
[0] LeeMongRyong 1 65.0 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[1] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[2] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[3] LeeSoonShin 2 80.0 true :1001, Jungang-daero, Yeonje-gu, Busan:
[4] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[5] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[6] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
[7] HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
empty():false, size():8, capacity():10


/******************************************************************************
 * 문제: 8
 * 요점: Person::passwd 멤버, getPasswd(), setPasswd(String passwd) 추가, set() 수정
 ******************************************************************************/
// 1) PersonManager 클래스의 login() 함수에 아래 내용을 추가하라
//    이 함수는 사용자로부터 pVector에 등록된 사용자 이름과 비밀번호를 입력 받아 
//    해당 객체를 활용하여 CurrentUser(p) 객체를 생성한 후 run() 함수를 실행한다. 
// 2) 아래의 findByName(String name) 함수도 login() 뒤에 복사하라.
//-----------------------------------------------------------------------------

    public void login() {  // Menu item 8
        String name = UI.getNext("user name: ");
        Person p = findByName(name);
        if (p == null) return;
        String passwd = UI.getNextLine("password: ");
        //passwd.strip();
        if (passwd.equals(p.getPasswd()))
            new CurrentUser(p).run();
        else
            System.out.println("WRONG password!!");
    }

    // pVector에 삽입되어 있는 Person 객체들 중 사용자가 입력한 이름 name과 
    // 동일한 이름을 가진 객체를 찾아 리턴한다.
    private Person findByName(String name) {
        int i, count = pVector.size();
        for (i = 0; i < count; ++i)
            if (name.equals(pVector.get(i).getName())) 
                return pVector.get(i);
        System.out.println(name + ": NOT found");
        return null;
    }

//-----------------------------------------------------------------------------
// 3) [1] Person 클래스에 String  passwd 멤버를 추가하라. 
//    [2] String getPasswd(), void setPasswd(String passwd) 멤버 함수를 구현하라.
//    [3] void set(name, String passwd, id, weight, married, address) 
//        멤버 함수의 두번째 인자로 위처럼 passwd를 추가하라.
//    주의: Person 생성자에는 passwd 매개변수를 추가하지 마라. 
//    [4] Person(name, id, weight, married, address) 생성자에서 
//        위 set()을 호출할 때 passwd 값으로 ""를 지정하라. 즉, 비번이 없음으로 설정하는 것이다.
//    [5] assign(Person p)에서 위 set()을 호출할 때는 passwd 값으로 p.passwd를 넘겨 주어라.
//    [6] clone()에서 새로운 객체를 복사 생성한 후에 새 객체의 passwd 값을 현 객체의 값으로 설정함
//    [7] inputMembers(Scanner sc)에서 passwd 멤버를 ""로 설정함
//-----------------------------------------------------------------------------

===============================================================================
==  프로그램 실행 결과 8
=============================================================================== 

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove =
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 8
user name: p3
password:             // 비번이 없으므로 그냥 [엔터]를 쳐라.

++++++++++++++++++++++ Current User Menu ++++++++++++++++++++++++
+ 0.logout 1.display 2.getter 3.setter 4.copy 5.whatAreYouDoing +
+ 6.equals 7.update                                             +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
menu item? 


/******************************************************************************
 * 문제: 8-1
 * 요점: CurrentUser::chPasswd() 추가
 ******************************************************************************/
// 1) CurrentUser::run() 내의 menuStr을 아래 문자열로 교체하라.
//-----------------------------------------------------------------------------
        String menuStr =
            "++++++++++++++++++++++ Current User Menu ++++++++++++++++++++++++\n" +
            "+ 0.logout 1.display 2.getter 3.setter 4.copy 5.whatAreYouDoing +\n" +
            "+ 6.isSame 7.update 8.chPasswd(4_2)                             +\n" +
            "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";

//-----------------------------------------------------------------------------
// 2) CurrentUser 내의 아래 함수를 추가하라 
//-----------------------------------------------------------------------------
    void chPasswd() {
        String passwd = UI.getNext("new password: ");
        user.setPasswd(passwd);
        System.out.println("password changed");
    }

//-----------------------------------------------------------------------------
// 3) 위 Current User Menu의 8번 항목을 선택되었을 때 위 chPasswd()가 호출되도록 
//    CurrentUser::run() 내의 switch 문장에 case를 추가하고, MENU_COUNT도 수정하라.
//-----------------------------------------------------------------------------

===============================================================================
==  프로그램 실행 결과 8-1
=============================================================================== 

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 8
user name: p3
password:             // 그냥 엔터

++++++++++++++++++++++ Current User Menu ++++++++++++++++++++++++
+ 0.logout 1.display 2.getter 3.setter 4.copy 5.whatAreYouDoing +
+ 6.isSame 7.update 8.chPasswd(4_2)                             +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
menu item? 8
new password: p3!!
password changed

++++++++++++++++++++++ Current User Menu ++++++++++++++++++++++++
+ 0.logout 1.display ...
menu item? 0

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 8
user name: p3
password:             // 그냥 엔터
WRONG password!!

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 8
user name: p3
password: p2!!
WRONG password!!

=========== Person Management Menu ...
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 8
user name: p3
password: p3!!

++++++++++++++++++++++ Current User Menu ++++++++++++++++++++++++
+ 0.logout 1.display 2.getter ...
menu item? 1
p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:


/******************************************************************************
 * 문제: 9
 ******************************************************************************/
// 5장에서 배울 상속 및 오버라이딩과 관련하여 사전에 정리해야 할 함수들이 있다. 
// 아래 지시에 따라 수정하라.
// 1) Person 클래스의 맨 마지막에 private void printMembers() { } 함수를 구현하라.
//    함수 내용은 기존 Person::print() 함수 내용을 그대로 복사해서 삽입하면 된다.
//
// 2) Person(name, id, weight, married, address) 생성자에서 
//    println("Person(): "); 대신 아래 문장으로 교체하라.
//
        System.out.print("Person(): ");  printMembers();  System.out.println();
//
// 3) Person::print() 함수를 아래와 같이 변경하라. 

    void print() { 
        printMembers(); 
    }

// 4) Person 클래스 내에  "// Candidates for virtual functions and overriding" 뒤에
//    equals(), print(), input(), whatAreYouDoing(), clone() 등의 함수들은
//    연속적으로 배치되도록 하라. 추후 상속된 클래스에서 이들 함수들은 오버라이딩될 것이다. 

===============================================================================
==  프로그램 실행 결과 9
=============================================================================== 
// 출력 내용은 기존과 동일해야 한다.

******* Main Menu ********
* 0.exit 1.PersonManager *
* 2.ch2 3.ch3            *
**************************
menu item? 1
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
PersonManager::run() starts
PersonManager(array[])
VectorPerson::VectorPerson(10)
Person::clone()
Person(): p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
Person::clone()
Person(): p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
Person::clone()
Person(): p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
Person::clone()
Person(): p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
Person::clone()
Person(): p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
display(): count 5
[0] p0 10 70.0 false :Gwangju Nam-gu Bongseon-dong 21:
[1] p1 11 61.1 true :Jong-ro 1-gil, Jongno-gu, Seoul:
[2] p2 12 52.2 false :1001, Jungang-daero, Yeonje-gu, Busan:
[3] p3 13 83.3 true :100 Dunsan-ro Seo-gu Daejeon:
[4] p4 14 64.4 false :88 Gongpyeong-ro, Jung-gu, Daegu:
empty():false, size():5, capacity():10

=========== Person Management Menu ==========
= 0.exit 1.display 2.clear 3.reset 4.remove =
= 5.copy 6.append 7.insert 8.login          =
=============================================
menu item? 


/******************************************************************************
 * 프로그램의 자동오류체크 방법
 ******************************************************************************/
// clc.chosun.ac.kr의 [강의자료실]의 "자동_오류_체크_방법" 파일을 참고하기 바란다.

// Main.java의 main() 함수 내에서 아래 문장의 [주석]을 제거하고 실행하면 자동오류체크가 실행된다.
        //int chk = 1; if (chk != 0) new AutoCheck(chk, true).run(); else

/******************************************************************************
 * 자동오류체크 실행결과
 ******************************************************************************/
test_1 : O
test_2 : O
test_3 : O
test_4 : O
test_5 : O
test_6 : O
test_7 : O
test_8 : O
Good bye!!

/******************************************************************************
 * 프로그램 제출
 ******************************************************************************/
// 1. 중요: Main.java의 main() 함수 내에서 아래 문장처럼 [주석] 처리한 후 저장하라.
        //int chk = 1; if (chk != 0) new AutoCheck(chk, true).run(); else
//    경고: 위 문장을 주석처리 하지 않은 채 제출할 경우 oj 시스템에서 컴파일 에러가 발생할 것이다. 
// 2. 프로그램 소스인 Main.java만을 oj.chosun.ac.kr에 제출하라. 
//    제출 시 AutoCheck.java 파일은 제출하지 않아도 된다.
//-----------------------------------------------------------------------------

*/

import java.util.*;

//===============================================================================
// main()
//===============================================================================
public class Main 
{
    public static void main(String[] args) {
        //--------------------------------
        // AutoCheck(chk, trace)
         //chk: 1(자동 오류 체크), 0(키보드에서 직접 입력하여 프로그램 실행)
        // trace: true(오류발생한 곳 출력), false(단순히 O, X만 표시)
        //--------------------------------
      //int chk = 1; if (chk != 0) new AutoCheck(chk, true).run(); else

        
       
        run(new Scanner(System.in));
    }

    public static void run(Scanner scan) {
        // UI 클래스의 setScanner() 함수를 호출함; setScanner()가 static 함수라 이렇게 호출 가능함
        UI.setScanner(scan); // UI 클래스 내의 static 함수 호출
        MainMenu.run(); // MainMenu 클래스 내의 static 함수 호출방법: 클래스이름.함수이름();
        
        scan.close();
        
    }
}

//===============================================================================
// Main Menu
//===============================================================================
class MainMenu
{
   public static final int MENU_COUNT = 4;
   
    public static void run() {
       String menuStr =
                "******* Main Menu ********\n" +
                "* 0.exit 1.PersonManager *\n" +
                "* 2.ch2 3.ch3            *\n" +
                "**************************\n";
        
        int menuItem;
        while(true) {
        menuItem = UI.selectMenu("\n"+menuStr, MENU_COUNT);
        
        if(menuItem == 0) {
       //System.out.println("menuItem: " + menuItem);
        System.out.println("\nGood bye!!");
        break;
       }
        else {
           switch(menuItem) {
           case 1:
              new MultiManager().run();
              break;
           case 2:
              Ch2.run();
              break;
           case 3:
              Ch3.run();
              break;
           default:
        System.out.println("menuItem: " + menuItem);
           }
        }
    }
  }
} // class MainMenu

//===============================================================================
//class Person: ch4_1
//===============================================================================
class Person 
{
 private String  name;    // 이름
 private int     id;      // Identifier
 private double  weight;  // 체중
 private boolean married; // 결혼여부
 private String  address; // 주소
 
 String passwd;
 

 
 // 생성자 함수들
 public Person(String name, int id, double weight, boolean married, String address) { 
    set(name,"", id, weight, married, address);
    System.out.print("Person(): ");  printMembers();  System.out.println();
 }
 
 public Person(String name) {
     this(name, 0, 0.0, false, "");
 }
 
 public Person(Scanner sc) { inputMembers(sc); }
 
 
 public void set(String name, String passwd, int id, double weight, boolean married, String address) {
    this.name = name;
    this.passwd = passwd;
    this.id = id;
    this.weight = weight;
    this.married = married;
    this.address = address;
 }
 
  
 public void println() { 
     print(); System.out.println(); 
 }
  
 public void println(String msg) { 
      System.out.print(msg); print(); System.out.println(); 
 }
 
 // assign() 함수
 public void assign(Person p) {
     this.name = p.name;
     this.passwd = p.passwd;
     this.id = p.id;
     this.weight = p.weight;
     this.married = p.married;
     this.address = p.address;
 }
 

 // Getter: getXXX() 관련 함수들
 public String getName() {
    return name;
 }
 
public int getId() {
    return id;
 }

public double getWeight() {
   return weight; 
 }

public boolean getMarried() {
    return married;
 } 

public String getAddress() {
    return address;
 }
  
 // Setter: overloading: set() 함수 중복
public void set(String name) {
    this.name = name;
 }

public void set(int id) {
    this.id = id;
 }

public void set(double weight) {
    this.weight = weight;
 }

public void set(boolean married) {
    this.married = married;
 }

public void setAddress(String address) {
    this.address = address;
 }

 // Candidates for virtual functions and overriding 
 // print(), clone(), whatAreYouDoing(), equals(), input() 함수
 void print() { 
    printMembers();
 }

public Person clone() {
    System.out.println("Person::clone()");
    Person clonedPerson = new Person(name, id, weight, married, address);
    return clonedPerson;
 }

public void whatAreYouDoing() {
   System.out.println(name +" is taking a rest.");
 }

public boolean equals(Object obj) {
   if(this == obj) {
      return true;
   }
   
   if(obj == null || getClass() != obj.getClass()) {
      return false;
   }
   
   Person other = (Person) obj;
   
   return this.id == other.id && this.name.equals(other.name);
 }

 public void input(Scanner sc) { 
    inputMembers(sc);
 }
 
 private void inputMembers(Scanner sc) {
       name = sc.next();
       passwd = "";
       id = sc.nextInt();
       weight = sc.nextDouble();
       married = sc.nextBoolean();

       while ((address = sc.findInLine(":.*:")) == null)
       sc.nextLine();
       //address = sc.nextLine();
       
       address = address.substring(1, address.length() - 1);
 }
 
 String getPasswd() {
    return passwd;
 }
 
 public void setPasswd(String passwd) {
   this.passwd = passwd; 
 }
 
 private void printMembers() {
    System.out.print(name+" "+id+" "+weight+" "+married+" :"+address+":");
 }
}

//===============================================================================
// User Interface
//===============================================================================
class UI
{
    public static boolean echo_input = false; // 자동오류체크 시 true로 설정됨
    public static Scanner scan;

    public static void setScanner(Scanner s) { scan = s; }

    // 입력을 받기 위해 static Scanner scan 멤버를 활용하라. 즉, scan.함수() 형식으로 호출
    // 정수 값을 입력 받아 리턴함 (음수, 0, 양수)
    public static int getInt(String msg) { 

        // TODO: msg를 화면에 출력한 후 정수 값을 입력 받아 지역 변수 value에 저장함 (변수 선언할 것)
       //       입력 시 이 클래스의 scan 멤버 변수를 활용하라. 
        //       (이 변수는 setScanner(Scanner s)에 의해 이미 초기화 되었음)
       int value = 0;
       while(true) {
          try {
             System.out.print(msg);
             value = scan.nextInt();
       
             scan.nextLine();

             if (echo_input) System.out.println(value);
             break;
         // 자동오류체크 시 입력 값을 출력함
        // 위 문장은 자동오류체크 시에 사용되는 문장임; 일반적으로 키보드로부터 입력받을 경우 
        // 화면에 자동 echo되지만, 자동오류체크 시에는 입력파일에서 입력받은 값이 자동 echo 되지  
        // 않으므로 명시적으로 출력 버퍼에 출력(echo) 해 주어야 한다.

        // (지시가 있을 때 구현할 것) 입력 버퍼에 남아 있는 '\n'를 제거하지 않으면 다음번 getLine()에서 
        // '\n'만 빈 줄이 입력될 수 있으므로 입력 버퍼에 남아 있는 '\n'를 사전에 제거함
       } catch(InputMismatchException e) {
          System.out.println(e); // 예외 종류 출력
            System.out.println("-----"); 
            e.printStackTrace();
             System.out.println("Input an INTEGER. Try again!!");
             scan.nextLine();
       }
     }
        return value; // TODO: 입력 받은 정수 value를 리턴할 것 
    }

    // 0 또는 양의 정수 값을 입력 받아 리턴함
    public static int getPosInt(String msg) { 
       int value;
       while(true) {
          value = getInt(msg);
          if(value >= 0) {
             //System.out.println("menu item: " + value);      
             break;
          } else {
             System.out.println("Input a positive INTEGER. Try again!!");
          }
       }
        return value;
    }
    
    // [0, (size-1)] 사이의 인덱스 값을 리턴함
    // 존재하지 않는 메뉴항목을 선택한 경우 에러 출력
    public static int getIndex(String msg, int size) { 
 
       int index;
       while (true) {
          index = getPosInt(msg);
          if(index >= 0 && index < size) {
             break;
          }
          else {
             System.out.println(index + ": OUT of selection range(0 ~ " + (size - 1) + ") Try again!!");
          }
       }
        return index;
    }

    // 사용자에게 메뉴("\n"+menuStr+"menu item? ")를 보여주고 
    // 위 getIndex(String msg, int size)를 호출해서
    // 사용자가 선택한 메뉴항목의 인덱스(0 ~ (menuCount-1))를 리턴함
    // menuCount: 메뉴항목의 개수임
    public static int selectMenu(String menuStr, int menuCount) { 
       
       int menuItem;
       while(true) {
          menuItem = getIndex("\n" + menuStr + "menu item? ", menuCount);
          if(menuItem >= 0 && menuItem < menuCount) {
             break;
          }
          else {
             System.out.println(menuItem + ": OUT of selection range(0 ~ " + (menuCount - 1) + ")Try again!!");
          }
       }
       return menuItem; 
       
    }

    // 중요: 위 각 함수 구현 시
    // selectMenu() -> getIndex() -> getPosInt() -> getInt() 를 호출해서 구현하여야 한다.

    // 위 getInt()를 참고하여 msg를 화면에 출력한 후 문자열 단어 하나를 입력 받아 리턴함
       
       
       
    public static String getNext(String msg) { 
        // TODO: msg를 화면에 출력한 후 하나의 토큰(단어)을 입력 받아 변수 token에 저장함
       System.out.print(msg);
       String token = scan.next();
       
       scan.nextLine();
       
        if (echo_input) System.out.println(token); // 자동오류체크 시 입력 값을 출력함
        return token;  // TODO: 입력 받은 한 단어를 리턴할 것
    }

    // msg를 화면에 출력한 후 하나의 행 전체를 입력 받아 리턴함
    public static String getNextLine(String msg) { 
        // TODO: msg를 화면에 출력한 후 한 행 전체를 입력 받아 변수 line에 저장함
       System.out.print(msg);
       
       String line = scan.nextLine();
       
        if (echo_input) System.out.println(line); // 자동체크 시 출력됨
        return line;  // TODO: 입력 받은 한 행 전체를 리턴할 것
    }
}

//===============================================================================
//CurrentUser class: ch4_1
//===============================================================================
class CurrentUser
{
 Person user;

 CurrentUser(Person user) { 
     this.user = user; 
 }

 public void run() {
    String menuStr =
               "++++++++++++++++++++++ Current User Menu ++++++++++++++++++++++++\n" +
               "+ 0.logout 1.display 2.getter 3.setter 4.copy 5.whatAreYouDoing +\n" +
               "+ 6.isSame 7.update 8.chPasswd(4_2)                             +\n" +
               "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
     final int MENU_COUNT = 9; // 상수 정의
     while (true) {
         int menuItem = UI.selectMenu(menuStr, MENU_COUNT);
         switch(menuItem) {
         case 1: display();         break;
         case 2: getter();          break;
         case 3: setter();          break;
         case 4: copy();            break;
         case 5: whatAreYouDoing(); break;
         case 6: equals();          break;
         case 7: update();          break;
         case 8: chPasswd();      break;
         case 0:                    return;
         }
     }
 }
 void display() { 
     user.println(); 
 } // Menu item 1

 void getter() { // Menu item 2
    System.out.println("name:" + user.getName() + ", id:" + user.getId() + ", weight:" +
             user.getWeight() + ", married:" + user.getMarried() +
             ", address:" + user.getAddress());
 }
 
 void setter() { // Menu item 3
    var p = new Person("p");
    
    p.set(p.getName());
     p.set(user.getId());
     p.set(user.getWeight());
     p.set(user.getMarried());
     p.setAddress(user.getAddress());
     p.println("p.set(): ");
 }
 
 void copy() { // Menu item 4
    user.println("user: ");
     var p = user.clone();
     p.println("p: ");
 }
 
 void whatAreYouDoing() {  // Menu item 5
    user.whatAreYouDoing();
 }
 
 void equals() { // Menu item 6
    user.println("user: ");
     var p = new Person("user"); 
     p.set(1);
     p.println("p: ");
     System.out.println("p.equals(user): " + p.equals(user));
     
     p.assign(user);
     p.println("p.assign(user): ");
     System.out.println("p.equals(user): " + p.equals(user));
 }
 
 void update() { // Menu item 7
    System.out.println("input person information:");
     user.input(UI.scan); // user 100 65 true :426 hakdong-ro, Gangnam-gu, Seoul:
     if (UI.echo_input) user.println(); // 자동오류체크시 출력됨
     display();
 }
 
 void chPasswd() { // Menu item 8
     String passwd = UI.getNext("new password: ");
     user.setPasswd(passwd);
     System.out.println("password changed");
 }
} // CurrentUser class: ch4_1

class VectorPerson
{
    static final int DEFAULT_SIZE = 10;

    private Person[] persons; // Person 객체 참조들의 배열, 즉 배열에 저장된 값이 Person 객체의 주소이다.
    private int count;        // persons 배열에 현재 삽입된 객체의 개수

    public VectorPerson() { this(DEFAULT_SIZE); }

    public VectorPerson(int capacity) {
        count = 0; // persons 배열에 현재 삽입된 객체의 개수는 0
        System.out.println("VectorPerson::VectorPerson("+capacity+")");
        persons = new Person[capacity]; // 객체 참조 배열 할당
    }
    
    // persons[index]의 값을 반환
    public Person get(int index) { 
          if(index <0 || index >= count) {
             return null;
          }
       
       return persons[index]; 
       }
     
    // 할당 받은 persons 배열의 전체 길이를 반환함 (count가 아님)
    public int capacity() { return persons.length; }
     
    // persons 배열에 현재 삽입된 객체의 개수를 0으로 설정
    public void clear() { 
       for(int i =0; i<count; i++) {
          persons[i] = null;
       }
       count = 0; 
    }
     
    // 현재 삽입된 객체 참조가 하나도 없으면 true, 있으면 false를 반환한다.
    // if 문장을 사용하지 말고 한 문장(return 비교연산자)으로 완셩할 것
    public boolean isEmpty() { return count == 0; }
     
    // 현재 삽입된 객체의 개수를 반환
    public int size() { return count; }

    // index 위치의 객체 p를 삭제한다. 즉, index+1부터 끝까지 객체들을 한칸씩 왼쪽으로 밀어 주어야 한다.
    // 자바에는 객체를 삭제하는 delete 명령어가 없다. 따라서 객체를 별도로 삭제할 필요는 없고 무시하라.
    void remove(int index) {
       if(index >= 0 && index < count) {
          for(int i = index; i < count -1; i++) {
             persons[i] = persons[i+1];
          }
          persons[count - 1] = null;
          count--;
       }
    }
    
    // persons 배열에 마지막 삽입된 원소 뒤에 새로운 원소 p를 삽입하고 현재 삽입된 객체 개수 증가
    // persons[]의 배열 크기가 작으면 extend_capacity()를 호출하여 먼저 배열을 확장한다.
    public void add(Person p) {
         if (count >= persons.length)
             extend_capacity();
         persons[count++] = p;
    }
    
    // 먼저 index부터 끝까지 객체들을 한칸씩 뒤로 밀어 준 후 index 위치에 객체 p를 삽입한다. 
    // persons[]의 배열 크기가 작으면 extend_capacity()를 호출하여 먼저 배열을 확장한다.
    public void add(int index, Person p) {
       if(index < 0 || index > count) {
          return;
       }
       if(count >= persons.length)
          extend_capacity();
       
       for(int i = count; i>index; i--) {
          persons[i] = persons[i - 1];
       }
       
       persons[index] = p;
       count++;
    }
    
    // persons[]의 배열 크기를 두배로 확장한다.
    // 기존 persons 변수를 다른 배열 변수에 임시로 저장한 후 
    // 현재의 두배 크기의 배열을 새로 할당 받아 persons에 저장한다.
    // 임시 변수에 있던 기존 값들을 모두 persons[]에 복사한다.
    public void extend_capacity() {
       int newCapacity = persons.length * 2;
        Person[] newPersons = new Person[newCapacity];
        for (int i = 0; i < count; i++) {
            newPersons[i] = persons[i];
        }
        persons = newPersons;
        System.out.println("VectorPerson: capacity extended to " + newCapacity);
        // 별도의 지시가 있을 때가지 구현하지 않아도 됨
    }
}   // VectorPerson class: ch4_2

class Factory
{
    public void printInputNotice(String preMsg, String postMsg) {
        System.out.println("input"+preMsg+" [person information]"+postMsg+":");
    }
    public Person inputPerson(Scanner sc) { 
       // user 100 65 true :426 hakdong-ro, Gangnam-gu, Seoul:
        var p = new Person(sc); // 위 행처럼 입력된 사람 정보를 입력 받음
        if (UI.echo_input) p.println(); // 자동오류체크시 출력됨
        return p; 
    }
}   // Factory class: ch4_2

class PersonManager
{
    static int cpCount = 0;
    private VectorPerson pVector;
    private Factory factory;
    private Person array[];

    public PersonManager(Person array[], Factory factory) {
        System.out.println("PersonManager(array[])");
        pVector = new VectorPerson();
        this.factory = factory;
        this.array = array;
        addArray();
        display();
    }

    public void run() {
        String menuStr =
            "=========== Person Management Menu ==========\n" +
            "= 0.exit 1.display 2.clear 3.reset 4.remove =\n" +
            "= 5.copy 6.append 7.insert 8.login          =\n" +
            "=============================================\n";
        final int MENU_COUNT = 9; // 상수 정의
        while (true) {
            int menuItem = UI.selectMenu(menuStr, MENU_COUNT);
            switch(menuItem) {
            case 1: display();         break;
            case 2: clear();           break;
            case 3: reset();           break;
            case 4: remove();          break;
            case 5: copy();            break;
            case 6: append();          break;
            case 7: insert();          break;
            case 8: login();           break;
            case 0:                    return;
            }
        }
    }
    public void display() { // Menu item 1
       int count = pVector.size();
        System.out.println("display(): count " + count);
        for (int i = 0; i < count; ++i) {
            System.out.print("[" + i + "] ");
            pVector.get(i).println();
        }
        System.out.println("empty():" + pVector.isEmpty() + ", size():" + pVector.size()
             + ", capacity():" + pVector.capacity());
    }
    public void clear() {  // Menu item 2
       pVector.clear();
        display();
    }
    public void reset() { // Menu item 3
       pVector.clear();
        addArray();
        display();
    }
    public void remove() { // Menu item 4
       if (pVector.size() == 0) {
            System.out.println("no entry to remove");
            return;
        }
        int index = UI.getIndex("index to delete? ", pVector.size());
        pVector.remove(index);
        display();
    }
    public void copy() { // Menu item 5
       cpCount++;
        for (int i = 0, size = pVector.size(); i < size; ++i) {
            Person p = pVector.get(i).clone();
            String name = p.getName();
            for (int j = 0; j < cpCount; ++j)
                name = name.charAt(0)+name;
            p.set(name);
            p.set(p.getId() + 20 * cpCount);
            p.set(p.getWeight() + cpCount);
            if (cpCount % 2 == 1)
                p.set(!p.getMarried());
            pVector.add(p);
        }
        display();
    }
    // 아래 함수는 사용자로부터 새로 추가할 Person 객체의 수를 입력 받고 for문을 이용하여
    // 그 개수만큼의 Person 객체를 생성하고 인적정보를 입력받은 후 (factory.inputPerson()을 통해)
    // VectorPerson pVector의 맨 끝에 추가한다.
    /* append() 실행 시 아래 항목들을 복사해서 순서적으로 입력하면 편하게 인적정보를 입력할 수 있음
    3
    HongGilDong 0 71.5 false :Gwangju Nam-gu Bongseon-dong 21:
    LeeMongRyong 1 65 true :Jong-ro 1-gil, Jongno-gu, Seoul:
    LeeSoonShin 2 80 true :1001, Jungang-daero, Yeonje-gu, Busan:
    */
    public void append() { // Menu item 6
       int count = UI.getPosInt("number of persons to append? ");
        factory.printInputNotice(" "+Integer.toString(count), " to append");
        for (int i = 0; i < count; ++i) {
            Person p = factory.inputPerson(UI.scan); // 한 사람의 정보를 입력 받음
            if (p != null) pVector.add(p);
        }
        display();
    }
    public void insert() { // Menu item 7
       int index = 0;
        if (pVector.size() > 0) {
            index = UI.getIndex("index to insert in front? ", pVector.size()+1);
            if (index < 0) return;
        }
        factory.printInputNotice("", " to insert");
        Person p = factory.inputPerson(UI.scan);
        if (p == null) return;
        pVector.add(index, p);
        display();
    }
    // 사용자로부터 VectorPerson pVector에 저장된 사람들 중에서 로그인할 사람의 이름(name)과 비번을 입력받고
    // 해당 비번이 맞으면 CurrentUser의 객체를 생성하고 이 객체의 run() 멤버 함수를 호출한다.
    // 초기 비번은 설정되어 있지 않기에 그냥 엔터치면 된다.
    public void login() {  // Menu item 8
       String name = UI.getNext("user name: ");
        Person p = findByName(name);
        if (p == null) return;
        String passwd = UI.getNextLine("password: ");
        //passwd.strip();
        if (passwd.equals(p.getPasswd()))
            new CurrentUser(p).run();
        else
            System.out.println("WRONG password!!");
    }
    
 // pVector에 삽입되어 있는 Person 객체들 중 사용자가 입력한 이름 name과 
    // 동일한 이름을 가진 객체를 찾아 리턴한다.
    private Person findByName(String name) {
        int i, count = pVector.size();
        for (i = 0; i < count; ++i)
            if (name.equals(pVector.get(i).getName())) 
                return pVector.get(i);
        System.out.println(name + ": NOT found");
        return null;
    }
    
    private void addArray() {
        for (Person p : array)
            pVector.add(p.clone()); // 배열의 각 원소를 복사한 후 pVector에  삽입함
    }
}   // ch4_2: PersonManager class

//===============================================================================
//class MultiManager: ch4_1
//===============================================================================
class MultiManager
{
    private Person persons[] = {
        new Person("p0", 10, 70.0, false, "Gwangju Nam-gu Bongseon-dong 21"),
        new Person("p1", 11, 61.1, true,  "Jong-ro 1-gil, Jongno-gu, Seoul"),
        new Person("p2", 12, 52.2, false, "1001, Jungang-daero, Yeonje-gu, Busan"),
        new Person("p3", 13, 83.3, true,  "100 Dunsan-ro Seo-gu Daejeon"),
        new Person("p4", 14, 64.4, false, "88 Gongpyeong-ro, Jung-gu, Daegu"),
    };
    // new를 이용해 동적으로 할당할 경우 소멸자 함수를 만들어 거기서 delete 해 주어야 함

    private Person allPersons[] = {
        persons[0], persons[1], persons[2], persons[3], persons[4],
    };

    public void run() {
        System.out.println("PersonManager::run() starts");
        var pm = new PersonManager(allPersons, new Factory());
        pm.run();
        System.out.println("PersonManager::run() returned");
    }
} // class MultiManager: ch4_1

//===============================================================================
//class Ch3
//===============================================================================
class Ch3 
{
   public static final int MENU_COUNT = 4;
   
  public static void run() {
      String menuStr =
           "************* Ch3 Menu **************\n" +
           "* 0.Exit 1.array 2.exception 3.game *\n" +
           "*************************************\n";

      // TODO: Ch2::run() 함수를 참고하여 while문과 switch문을 작성하라.
      //       switch에서는 아래의 상응하는 함수를 호출하고, MENU_COUNT도 적절히 수정하라.
      int menuItem;
      while(true) {
         menuItem = UI.selectMenu("\n"+menuStr, MENU_COUNT);
         switch(menuItem) {
         case 0:
            return;
         case 1:
            array();
            break;
         case 2:
            exception();
            break;
         case 3:
            game();
            break;
       default:
          System.out.println("menuItem: " + menuItem);
          break;
         }
      
      }
  }
 

  public static void array() {
      double arr1[][] = { {0}, {1,2}, {3,4,5} };
      printArray(arr1);
      double arr2[][] = { {0,1,2,3}, {4,5,6}, {7,8}, {9} };
      printArray(arr2);
     // System.out.println("arr length: ");
      
     var arr3 = inputArray();
     printArray(arr3);
     arr3 = inputArray();
     printArray(arr3);
     
      
  }
  public static void printArray(double arr[][]) {
     System.out.println("arr length: "+arr.length);
     for(int i=0; i<arr.length; i++) {
        System.out.print("arr["+i+"] ");
        for(int j=0; j<arr[i].length;j++) {
           System.out.print(arr[i][j]+" ");
        }
        System.out.println();
     }
     System.out.println();
  }
  
  public static double[][] inputArray() {
     int row;
     System.out.print("array rows? ");
     row = UI.scan.nextInt();
     double arr[][] = new double[row][];
     for(int i=0; i<row; i++) {
        System.out.print("input "+(i+1)+" doubles for row "+i+": ");
        arr[i] = new double[i+1];
        for(int j=0; j<=i; j++) 
           arr[i][j] = UI.scan.nextDouble();
    }
     System.out.println();
     return arr;
  }
  
  static Random random = null; // 난수 발생기
  
  public static void exception() {

     var random = new Random(UI.getInt("seed for random number? "));// 난수 발생기
     String str;
     int i;
     int arr[];
     while(true) {
        try {
           str = UI.getNext("array[] size? ");
            i = Integer.parseInt(str);   // 문자열 숫자를 정수로 변환: "123" -> 123
            arr= new int[i];
           break;
        }
        catch(NumberFormatException e) {
           System.out.println(e);
           continue;
        }
        catch(NegativeArraySizeException e) {
           System.out.println(e);
           continue;
        }
     }


     for (i = 0; i < arr.length; ++i) // arr[] 전체를 난수 값으로 초기화
          arr[i] = random.nextInt(3);  // [0,1,2] 범위의 난수 발생
     System.out.print("array[]: { ");
     for (var v : arr)                // 배열 전체 출력
          System.out.print(v+" ");     // 각각의 v=arr[i] 원소 값을 출력함  
     System.out.println("}");
     while(true) {
        try {
           i = UI.getPosInt("array[] index? ");
           System.out.println("array["+i+"] = "+arr[i]);
           break;
        }
        catch(ArrayIndexOutOfBoundsException e) {
           System.out.println(e);
           continue;
        }
     }
     
     int numerator   = UI.getIndex("numerator   index? ", arr.length); // 분자 index
     while(true) {
        try {
           int denominator = UI.getIndex("denominator index? ", arr.length); // 분모 index
              System.out.println(arr[numerator]+" / "+arr[denominator]+" = "
                    +(arr[numerator] / arr[denominator]));
              break;
        }
        catch(ArithmeticException e) {
           System.out.println(e);
           continue;
        }
     }
      System.out.println("makeArray(): first");
     while(true) {
        try {
           arr = makeArray();
           break;
        }
        catch(OutOfMemoryError e) {
           System.out.println(e);
           continue;
        }
        catch(NullPointerException e) {
           System.out.println("NullPointerException");
           continue;
        }
     }
      System.out.println("makeArray(): second");
     while(true) {
        try {
           arr = makeArray();
           System.out.println("array length = "+arr.length);
           break;
        }
        catch(OutOfMemoryError e) {
           System.out.println(e);
           continue;
        }
        catch(NullPointerException e) {
           System.out.println("NullPointerException");
           continue;
        }
     }

     }

  // tag 0: OutOfMemoryError, 1: return null pointer, 2: return normal array
  public static int[] makeArray() { 
      int tag = UI.getPosInt("makeArray tag[0,1,2]? ");
     return (tag == 0)? new int[0x7fffffff]: (tag == 1)? null: new int[10]; 
  }
  
  public static void game() {
      final int USER = 0;     // 상수 정의
      final int COMPUTER = 1;
      String MJBarray[] = { "m", "j", "b" }; // 묵(m) 찌(j) 빠(b) 문자열을 가진 배열
      System.out.println("Start the MUK-JJI-BBA game.");
      // 난수 발생기
      random = new Random(UI.getInt("seed for random number? "));
      // 누가 우선권을 가졌는지 저장하고 있음, USER:사용자 우선권, COMPUTER:computer 우선권
      int priority = USER; 
      String priStr[] = { "USER", "COMPUTER"}; // 우선권을 화면에 출력할 때 사용할 문자열

      while(true) {
         System.out.println();
         System.out.println(priStr[priority] + " has the higher priority.");//를 출력
        String user = UI.getNext("m(muk), j(jji), b(bba) or stop? ");//를 출력하고
         // 사용자가 입력한 묵찌빠 문자열을 넘겨 받아 user 변수에 저장 (사용자가 묵찌빠 중 하나 선택)
         if(user.equals("stop")) { 
            System.out.println();
            return;
         } else if (!user.equals("m") && !user.equals("j") && !user.equals("b")) {
            System.out.println("Select one among m, j, b.");
            continue;
         }
         
         String computer = MJBarray[random.nextInt(MJBarray.length)];
         
         System.out.println("User = " + user + ", Computer = " + computer + ", ");
         
         if(user.equals(computer)) {
            System.out.println(priStr[priority] + " WINs."); 
         } else {
            System.out.println("SAME.");
            
            if((user.equals("m") && computer.equals("j")) ||
              (user.equals("j") && computer.equals("b")) ||
              (user.equals("b") && computer.equals("m"))) {
               priority = USER;
            } else {
               priority = COMPUTER;
            }
         }
          // 사용자가 입력한 문자열을 비교할 때는 if (user.equals("stop")) 문장을 사용 
         // 사용자가 m, j, b를 입력하지 않고 다른 문자열을 입력했다면 
          //    "Select one among m, j, b."를 출력하고 while()의 처음부터 다시 시작
          // [0,1,2] 난수를 이용하여 COMPUTER가 묵찌빠 중 하나를 선택함
       //   String computer = MJBarray[random.nextInt(MJBarray.length)];
          //user와 computer 변수를 이용하여 화면에 사용자, 컴퓨터가 낸 묵찌빠 값을 출력 
             // (예:User = m, Computer = b, )
         // 이후 user와 computer 문자열을 비교하여 같으면 
              // user와 computer 두 문자열 비교하는 방법: if (user.equals(computer)) 
              // 우선권을 가진 사람의 묵찌빠와 동일한 묵찌빠를 상대방이 냈을 경우 우선권을 가진 사람이 승리함
            //  우선권을 가진 자(priStr[priority])가 " WINs." 했다고 출력하고
         // 같지 않으면 (비겼음) 
           //   "SAME." 출력
           //   현 상황을 (가위바위보)라 가정하고 누가 이겼는지 판단하여 우선권(priority)을 가진자 결정 
           //   즉, priority 값을 가위바위보상 이긴 자(USER 또는 COMPUTER)로 변경함
           //   (아주 긴 조건문이 될 것임)
         
      }
  }
}

//===============================================================================
// class Ch2
//===============================================================================
class Ch2 
{
   public static final int MENU_COUNT = 6;
   
    public static void run() {
        String menuStr =
             "************* Ch2 Menu ***********\n" +
             "* 0.exit 1.output 2.readToken    *\n" +
             "* 3.readLine 4.operator 5.switch *\n" +
             "**********************************\n";

        
        int menuItem;
        while(true) {
           menuItem = UI.selectMenu("\n"+menuStr, MENU_COUNT);
           switch(menuItem) {
           case 0: 
              return;
           case 1:
              output();
              break;
           case 2:
              readToken();
              break;
           case 3:
              readLine();
              break;
           case 4:
              operator();
              break;
           case 5:
              switchCase();
              break;
           default:
              System.out.println("menuItem: " + menuItem);
              break;
           }
        }
    }

    public static void output()     {
        String toolName = "JDK";
         double version = 1.8;
         String released = "is released.";

         System.out.println(toolName + version + released);
         System.out.println(toolName + " " + version + " " + released);

         int i1 = 1, i2 = 2, i3 = 3; // 변수 선언과 함께 초기화

         System.out.println(i1+i2+i3);
         System.out.println(i1+""+i2+i3);
         System.out.println(i1+i2+i3+" "+i1+""+i2+i3);

         boolean b = true;
         double d = 1.2;

         System.out.println(b+" " + !b + " " + d);
    }
    
    public static void readToken()  {
       String  name;    // 이름
        int     id;      // Identifier
        double  weight;  // 체중
        boolean married; // 결혼여부
        String  address; // 주소

    
        System.out.println("person information(name id weight married :address:):");
     
        name = UI.scan.next();
        id = UI.scan.nextInt();
        weight = UI.scan.nextDouble();
        married = UI.scan.nextBoolean();

        // 주소의 패턴 ":address:"을 읽어 들임: 이미 완성된 코드이므로 아래 address를 바로 활용하면 됨
        while ((address = UI.scan.findInLine(":.*:")) == null)
           UI.scan.nextLine();  // 현재 행에 주소가 없다면 그 행을 스킵함
        address = address.substring(1, address.length()-1); // 주소 양 끝의 ':' 문자 삭제

        System.out.println(name + " " + id + " " + weight + " " + married + " :" + address + ":");
    }
    
    public static void readLine()   {
       String name = UI.getNext("name? "); // "name? "을 출력한 후 이름을 입력 받음
        // TODO: 실행결과("name: p")처럼 출력
       System.out.println("name: " + name);
        int id = UI.getInt("id? ");         // "id? "을 출력한 후 id을 입력 받음
        // TODO: 실행결과("id: 1")처럼 출력
        System.out.println("id: " + id);
        
        String address = UI.getNextLine("address? ");// "address? " 출력 후 한줄 전체 입력받음
        // TODO: 문자열 address를 실행결과("address :seoul gangnam:")처럼 출력하라.
        System.out.println("address :" + address+":");
    }
    
    public static void printBinStr(int v) {
       String s = Integer.toBinaryString(v);
        for (int i=0; i < (32-s.length()); ++i)
            System.out.print('0');
        System.out.println(s);
    }
  
    public static void operator() {
        int b = 0b11111111_00000000_11111111_11111111;
        printBinStr(b);

        // TODO: 변수 b를 왼쪽으로 4비트 이동시킨 값을 출력하라.
        b = b << 4;
        printBinStr(b);

        System.out.println();
        b = 0b11111111_00000000_00000000_11111111;
        printBinStr(b);

        // TODO: 변수 b를 4비트 산술적 오른쪽 시프트를 한 값을 출력하라.
        b = b >> 4;
        printBinStr(b);

        // TODO: 변수 b를 4비트 논리적 오른쪽 시프트를 한 값을 출력하라.
        b = 0b11111111_00000000_00000000_11111111;
        b = b >>> 4;
       printBinStr(b);
    }
    
    public static void switchCase() {
       
  
            String menuStr =
                "********* Switch Menu *********\n" +
                "* 0.exit 1.output 2.readToken *\n" +
                "* 3.readLine 4.operator       *\n" +
                "*******************************\n";
               
            while (true) {
                String menu = UI.getNext("\n"+menuStr+"menu item string? ");
                // menu는 메뉴항목 번호가 아닌 메뉴항목 단어를 직접 입력 받은 것임
                // TODO: Ch2.run()을 참조하여 switch 문장을 이용하여 상응하는 함수를 호출하라.
                //      단, 입력된 메뉴항목이 정수가 아니라 문자열(menu)임을 명심하라.
                //      즉, case 문장이 정수가 아니라 문자열과 비교 되어야 한다. 
                switch(menu) {
                case "exit":
                   return;
                case "output":
                   output();
                   break;
                case "readToken":
                   readToken();
                   break;
                case "readLine":
                   readLine();
                   break;
                case "operator":
                   operator();
                   break;
                }
           
    }
}
}
